import asyncio
import os
from aiogram import Bot, Dispatcher, F
from dotenv import load_dotenv
from datetime import datetime, timedelta
from aiogram.types import Message, ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery, BufferedInputFile, InputFile, URLInputFile, FSInputFile
from aiogram.filters.state import State, StatesGroup
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import default_state
from babel.dates import format_date
import numpy as np
import pandas as pd
from matplotlib.table import Table
import re
import html
import aiohttp
import tempfile
from PIL import Image, ImageDraw, ImageFont, ImageEnhance
import io
from logger import logging
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from database import User

load_dotenv()

bot = Bot(os.getenv('TOKEN'))
dp = Dispatcher()
scheduler = AsyncIOScheduler()

class AuthStates(StatesGroup):
    login = State()
    password = State()

class DiaryDateStates(StatesGroup):
    waiting_for_date = State()

def remove_unpaired_asterisks(text):
    asterisk_count = text.count("*")
    if asterisk_count % 2 != 0:
        text = text.replace("*", "", 1) if asterisk_count > 0 else text
        return remove_unpaired_asterisks(text)
    return text

def markdown_protect(text):
    text = str(text)
    text = text.replace("\r\n", "\n")
    text = remove_unpaired_asterisks(text)
    return re.sub(r"([_*\[\]()~`>#+\-=|{}.!\\-])", r"\\\1", text)


@dp.message(default_state, F.text == '/start')
async def start(message: Message, state: FSMContext):
    await state.clear()
    user = User.get_or_none(id=message.from_user.id)
    if user and user.login and user.password:
        logging.info(f"{message.from_user.id} | /start")
        markup = ReplyKeyboardMarkup(keyboard=[
        [KeyboardButton(text='üìñ –î–Ω–µ–≤–Ω–∏–∫'), KeyboardButton(text='üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ')],
        [KeyboardButton(text='üìä –£—Å–ø–µ–≤–∞–µ–º–æ—Å—Ç—å'), KeyboardButton(text='‚ùå –ü—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ —É—Ä–æ–∫–∏')],
        [KeyboardButton(text='üë§ –ü—Ä–æ—Ñ–∏–ª—å')]
    ], resize_keyboard=True)
        await message.answer(f"üëã –ü—Ä–∏–≤–µ—Ç, {user.FIO}! –í—ã —É–∂–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã.", reply_markup=markup)
    else:
        logging.info(f"{message.from_user.id} | –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è")
        markup = ReplyKeyboardMarkup(keyboard=[
            [KeyboardButton(text='–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è')]
        ], resize_keyboard=True, one_time_keyboard=True)
        await message.answer("üëã –ü—Ä–∏–≤–µ—Ç! –ß—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è.", reply_markup=markup)


@dp.message(default_state, F.text == '–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è')
async def start_auth(message: Message, state: FSMContext):
    await message.answer("üîë –í–≤–µ–¥–∏—Ç–µ –≤–∞—à –ª–æ–≥–∏–Ω:", reply_markup=ReplyKeyboardRemove())
    await state.set_state(AuthStates.login)



@dp.message(AuthStates.login)
async def get_login(message: Message, state: FSMContext):
    await state.update_data(login=message.text)
    await message.reply('üîí –í–≤–µ–¥–∏—Ç–µ –≤–∞—à –ø–∞—Ä–æ–ª—å:')
    await state.set_state(AuthStates.password)
    logging.debug(f"{message.from_user.id} | –ü—Ä–∏–Ω—è–ª–∏ –ª–æ–≥–∏–Ω")





@logging.catch()
@dp.message(AuthStates.password)
async def get_password(message: Message, state: FSMContext):
    user_data = await state.get_data()
    login = user_data['login']
    password = message.text
    logging.debug(f"{message.from_user.id} | –ü—Ä–∏–Ω—è–ª–∏ –ø–∞—Ä–æ–ª—å")

    try:
        async with aiohttp.ClientSession() as session:
            user: User = User.create(id=message.from_user.id)
            await user.credentials(login, password, session)
            print(await user.get_new_grades(session))
            markup = ReplyKeyboardMarkup(keyboard=[
                [KeyboardButton(text='üìñ –î–Ω–µ–≤–Ω–∏–∫'), KeyboardButton(text='üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ')],
                [KeyboardButton(text='üìä –£—Å–ø–µ–≤–∞–µ–º–æ—Å—Ç—å'), KeyboardButton(text='‚ùå –ü—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ —É—Ä–æ–∫–∏')],
                [KeyboardButton(text='üë§ –ü—Ä–æ—Ñ–∏–ª—å')]
            ], resize_keyboard=True)

            await message.reply(f'‚úÖ –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞, {user.FIO}!', reply_markup=markup)
            await message.delete()
            logging.success(f"{message.from_user.id} | {user.FIO} | –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞")
            await state.clear()

    except Exception as e:
        await message.reply(f'‚ùå –û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏: {e}. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑. /start')
        logging.error(f"{message.from_user.id} | {e} –û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏")
        user.delete_instance()
        await state.clear()

@dp.message(F.text == 'üìñ –î–Ω–µ–≤–Ω–∏–∫')
async def diary(message: Message, state: FSMContext):
    user: User = User.get_or_none(id=message.from_user.id)
    if user:
        today = datetime.now()
        keyboard = []
        for i in range(-2, 7):
            date = today + timedelta(days=i)
            date_str = date.strftime("%Y-%m-%d")
            day_name = date.strftime("%A")
            button_text = f"{date.strftime('%d.%m.%Y')} ({format_date(date, 'EEEE', locale='ru_RU').title()})"
            keyboard.append([InlineKeyboardButton(text=button_text, callback_data=f"diary_date:{date_str}")])

        markup = InlineKeyboardMarkup(inline_keyboard=keyboard)
        await state.update_data(original_message_id=message.message_id+1)
        
        await message.reply("–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É:", reply_markup=markup)
        await state.set_state(DiaryDateStates.waiting_for_date)
        logging.debug(f'{message.from_user.id} | {user.FIO} | –≤—ã–≤–æ–¥ –¥–∞—Ç –¥–Ω–µ–≤–Ω–∏–∫–∞')
    else:
        await message.reply("–°–Ω–∞—á–∞–ª–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è. /start")


@dp.callback_query(DiaryDateStates.waiting_for_date, F.data.startswith('diary_date:'))
async def process_diary_date(callback_query: CallbackQuery, state: FSMContext):
    await callback_query.answer()
    user = User.get_or_none(id=callback_query.from_user.id)
    if user:
        date_str = callback_query.data.split(":")[1]
        async with aiohttp.ClientSession() as session:
            await user._check_token_expire(session)
            diary = await user._fetch_data('http://api-mobile.nz.ua/v1/schedule/diary', [date_str], session)
        data = await state.get_data()
        original_message_id = data.get('original_message_id')
        if diary and diary.get('dates'):
            date_data = diary['dates'][0]
            date_str_display = html.escape(date_data['date'])
            calls = date_data['calls']

            diary_html = f"üìÖ <b>–î–Ω–µ–≤–Ω–∏–∫ –∑–∞ {date_str_display}:</b>\n\n"

            for call in calls:
                call_number = call['call_number']
                subjects = call['subjects']

                for subject in subjects:
                    subject_name = html.escape(subject['subject_name'])
                    teacher_name = html.escape(subject['teacher']['name']) if subject.get('teacher') else "‚Äî" 
                    lessons = subject['lesson']
                    hometask = subject['hometask']
                    diary_html += f"<b>{call_number}. {subject_name} ({teacher_name}):</b>\n"


                    for lesson in lessons:
                        lesson_type = html.escape(lesson['type'])
                        mark = html.escape(lesson['mark']) if lesson['mark'] else "‚Äî"
                        comment = html.escape(lesson['comment']) if lesson['comment'] else ""
                        diary_html += f"    - {lesson_type}: {mark} {comment}\n"

                    if any(hometask):
                        diary_html += "    - <b>–î–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ:</b>\n"
                        for task in hometask:
                            escaped_task = html.escape(task)
                            diary_html += f"      - {escaped_task}\n"
                    else:
                        diary_html += "     - –î–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç\n"

            await bot.edit_message_text(text=diary_html, chat_id=callback_query.message.chat.id,
                message_id=original_message_id,
                parse_mode="HTML", disable_web_page_preview=True
            )
            logging.success(f'{callback_query.message.from_user.id} | {user.FIO} | –í—ã–≤–æ–¥ –¥–Ω–µ–≤–Ω–∏–∫–∞ –∑–∞ {date_str}')


        else:
                await bot.edit_message_text(
                text="–ù–∞ –≤—ã–±—Ä–∞–Ω–Ω—É—é –¥–∞—Ç—É –Ω–µ—Ç –∑–∞–ø–∏—Å–µ–π –≤ –¥–Ω–µ–≤–Ω–∏–∫–µ.",
                chat_id=callback_query.message.chat.id,
                message_id=original_message_id,

            )

        await state.clear()

@dp.message(F.text == 'üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ')
async def timetable(message: Message):
    user: User = User.get_or_none(id=message.from_user.id)
    if user:
        today = datetime.now()
        start_of_week = today - timedelta(days=today.weekday())
        end_of_week = start_of_week + timedelta(days=6)
        dates = [start_of_week.strftime("%Y-%m-%d"), end_of_week.strftime("%Y-%m-%d")]
        async with aiohttp.ClientSession() as session:
            await user._check_token_expire(session)
            diary_data = await user._fetch_data('http://api-mobile.nz.ua/v1/schedule/timetable', dates, session)

        if diary_data and diary_data.get('dates'):
            timetable_html = "üìÖ <b>–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –Ω–µ–¥–µ–ª—é:</b> ‚ú®\n\n"

            for day_data in diary_data['dates']:
                date_str_display = day_data['date']
                day_name = format_date(datetime.strptime(date_str_display, '%Y-%m-%d'), 'EEEE', locale='ru_RU').title()
                timetable_html += f"<b>{day_name} ({date_str_display}):</b> üóìÔ∏è\n"

                if day_data.get('calls'):
                    for call in day_data['calls']:
                        call_number = call['call_number']
                        subjects = call['subjects']
                        timetable_html += f"<i>{call_number}.</i> "

                        for subject in subjects:
                            subject_name = html.escape(subject['subject_name'])
                            teacher_name = html.escape(subject['teacher']['name']) if subject.get('teacher') else "‚Äî"
                            timetable_html += f"{subject_name} ({teacher_name}) \n"

                else:
                    timetable_html += "–ù–µ—Ç —É—Ä–æ–∫–æ–≤ üéâ\n"

            await message.reply(timetable_html, parse_mode="HTML")
            logging.success(f'{message.from_user.id} | {user.FIO} | –í—ã–≤–æ–¥ —Ä–∞—Å—Å–ø–∏—Å–∞–Ω–∏—è')
        else:
            await message.reply("–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ —ç—Ç—É –Ω–µ–¥–µ–ª—é –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. üòî")

    else:
        await message.reply("–°–Ω–∞—á–∞–ª–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è. /start")


@dp.message(F.text == 'üìä –£—Å–ø–µ–≤–∞–µ–º–æ—Å—Ç—å')
async def student_performance(message: Message):
    user: User = User.get_or_none(id=message.from_user.id)
    if user:
        today = datetime.now()
        start_date = today.replace(day=1).strftime("%Y-%m-%d")
        end_date = today.strftime("%Y-%m-%d")
        try:
            async with aiohttp.ClientSession() as session:
                    await user._check_token_expire(session)
                    performance_data = await user._fetch_data(
                        'http://api-mobile.nz.ua/v1/schedule/student-performance',
                        [start_date, end_date], session
                    )

            if performance_data and performance_data.get('subjects'):
                performance_html = "üìä <b>–£—Å–ø–µ–≤–∞–µ–º–æ—Å—Ç—å –∑–∞ —Ç–µ–∫—É—â–∏–π –º–µ—Å—è—Ü:</b>\n\n"

                for subject in performance_data['subjects']:
                    subject_name = html.escape(subject['subject_name'])
                    marks = subject.get('marks', [])
                    if marks:
                        try:
                            avg_grade = round(sum(int(mark) for mark in marks) / len(marks), 2)
                            performance_html += f"<b>{subject_name}:</b> {avg_grade}\n"
                        except (ValueError, TypeError):
                            performance_html += f"<b>{subject_name}:</b> –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –≤—ã—á–∏—Å–ª–∏—Ç—å —Å—Ä–µ–¥–Ω–∏–π –±–∞–ª–ª (–Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –æ—Ü–µ–Ω–∫–∏)\n"
                    else:
                        performance_html += f"<b>{subject_name}:</b> –ù–µ—Ç –æ—Ü–µ–Ω–æ–∫\n"

                if performance_data.get('missed'):
                    missed_days = performance_data['missed'].get('days', 0)
                    missed_lessons = performance_data['missed'].get('lessons', 0)
                    performance_html += f"\n<b>–ü—Ä–æ–ø—É—â–µ–Ω–æ –¥–Ω–µ–π:</b> {missed_days}\n"
                    performance_html += f"<b>–ü—Ä–æ–ø—É—â–µ–Ω–æ —É—Ä–æ–∫–æ–≤:</b> {missed_lessons}\n"
                image = user.generate_image()

                with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as temp_file:
                    temp_file.write(image)
                    temp_file_name = temp_file.name
                logging.debug(temp_file_name)
                photo = FSInputFile(temp_file_name, filename='performance_img.png')
                await message.answer_photo(photo, caption=performance_html, parse_mode="HTML")

                os.remove(temp_file_name)

                logging.success(f'{message.from_user.id} | {user.FIO} | –í—ã–≤–æ–¥ —É—Å–ø–µ–≤–∞–µ–º–æ—Å—Ç–∏')

            else:
                await message.reply("–î–∞–Ω–Ω—ã–µ –æ–± —É—Å–ø–µ–≤–∞–µ–º–æ—Å—Ç–∏ –∑–∞ —ç—Ç–æ—Ç –º–µ—Å—è—Ü –ø–æ–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã.")

        except Exception as e:
            logging.exception(f"An unexpected error occurred: {e}")
            await message.reply(f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞: {e}")

    else:
        await message.reply("–°–Ω–∞—á–∞–ª–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è. /start")
marks2emoji = {
    1: "üí©",
    2: "üíÖ",
    3: "‚ò†Ô∏è",
    4: "‚ú®",
    5: "ü§°",
    6: "üíû",
    7: "üòÖ",
    8: "ü•≥",
    9: "ü•π",
    10: "üî•",
    11: "ü•µ",
    12: "üòé",
}

# ...

async def background_task():
    async with aiohttp.ClientSession() as session:
        while True:
            time_all = datetime.now()
            users = list(User.select().where(User.token_expired != None))
            
            for user in users:
                try:
                    time_user = datetime.now()
                    
                    marks = await user.get_new_grades(session)
                    logging.success(marks)
                    if not marks or not marks['new_grades']:
                        continue
                    
                    for grade in marks['new_grades']:
                        emoji = marks2emoji[int(grade['mark'])]
                        message = (
                            f"{emoji} *–ù–æ–≤–∞—è –æ—Ü–µ–Ω–∫–∞!* {emoji}\n\n"
                            f"*–û—Ü–µ–Ω–∫–∞:* {grade['mark']}\n"
                            f"*–ü—Ä–µ–¥–º–µ—Ç:* {grade['subject']} ({grade['lesson_type']})\n"
                            f"*–î–∞—Ç–∞:* {grade['lesson_date']}\n"
                        )
                        
                        if grade['comment']:
                            message += f"*–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:* {markdown_protect(grade['comment'])}\n"
                        
                        try:
                            await bot.send_message(user.id, message, parse_mode="Markdown")
                            logging.info(f"{user.FIO} –ù–æ–≤–∞—è –æ—Ü–µ–Ω–∫–∞ {grade['mark']} | {grade['subject']}")
                        except Exception as e:
                            logging.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user.FIO}: {e}")
                    
                    if marks['updated_grades']:
                        for grade_data in marks['updated_grades']:
                            new_grade = grade_data['new']
                            old_grade = grade_data['old']
                            
                            emoji = marks2emoji[int(new_grade['mark'])]
                            message = (
                                f"{emoji} *–ò–∑–º–µ–Ω–µ–Ω–∏–µ –æ—Ü–µ–Ω–∫–∏!* {emoji}\n\n"
                                f"*–ü—Ä–µ–¥–º–µ—Ç:* {new_grade['subject']} ({new_grade['lesson_type']})\n"
                                f"*–î–∞—Ç–∞:* {new_grade['lesson_date']}\n"
                                f"*–û—Ü–µ–Ω–∫–∞:* {old_grade['mark']} -> {new_grade['mark']}\n"
                            )
                            
                            if old_grade['comment']:
                                message += f"*–°—Ç–∞—Ä—ã–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:* {markdown_protect(old_grade['comment'])}\n"
                            if new_grade['comment']:
                                message += f"*–ù–æ–≤—ã–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:* {markdown_protect(new_grade['comment'])}\n"
                            
                            try:
                                await bot.send_message(user.id, message, parse_mode="Markdown")
                                logging.info(f"{user.FIO} –ò–∑–º–µ–Ω–µ–Ω–∏–µ –æ—Ü–µ–Ω–∫–∏ {old_grade['mark']} -> {new_grade['mark']} | {new_grade['subject']}")
                            except Exception as e:
                                logging.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user.FIO}: {e}")
                
                except Exception as e:
                    logging.exception(f"–û—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ: {e}. –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ä–∞–±–æ—Ç—É")
                finally:
                    logging.debug(f"	{user.FIO} - ({datetime.now() - time_user}) {marks if marks else None}")
            
            logging.info(f'–í—Ä–µ–º—è —Ü–∏–∫–ª–∞: {datetime.now() - time_all}')
            await asyncio.sleep(60)


@dp.message(F.text == '‚ùå –ü—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ —É—Ä–æ–∫–∏')
async def missed_lessons(message: Message):
    user: User = User.get_or_none(id=message.from_user.id)
    if user:
        today = datetime.now()
        start_of_month = today.replace(day=1)
        end_of_month = (today.replace(month=today.month + 1, day=1) - timedelta(days=1))
        dates = [start_of_month.strftime("%Y-%m-%d"), end_of_month.strftime("%Y-%m-%d")]

        try:
            async with aiohttp.ClientSession() as session:
                missed_lessons_data = await user._fetch_data('http://api-mobile.nz.ua/v1/schedule/missed-lessons', dates, session)

            if missed_lessons_data and missed_lessons_data.get('missed_lessons'):
                missed_lessons_html = "‚ùå <b>–ü—Ä–æ–ø—É—â–µ–Ω–Ω—ã–µ —É—Ä–æ–∫–∏ –∑–∞ –º–µ—Å—è—Ü:</b>\n\n"

                for lesson in missed_lessons_data['missed_lessons']:
                    lesson_date = lesson['lesson_date']
                    lesson_number = lesson['lesson_number']
                    subject_name = html.escape(lesson['subject'])
                    missed_lessons_html += f"<b>–î–∞—Ç–∞:</b> {lesson_date}, <b>–£—Ä–æ–∫:</b> {lesson_number}, <b>–ü—Ä–µ–¥–º–µ—Ç:</b> {subject_name}\n"
                
                await message.reply(missed_lessons_html, parse_mode="HTML")
                logging.success(f'{message.from_user.id} | {user.FIO} | –í—ã–≤–æ–¥ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö —É—Ä–æ–∫–æ–≤')

            else:
                await message.reply("–í —ç—Ç–æ–º –º–µ—Å—è—Ü–µ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö —É—Ä–æ–∫–æ–≤ –Ω–µ—Ç. üéâ")

        except Exception as e:
            logging.error(f"{message.from_user.id} | {user.FIO} | –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö —É—Ä–æ–∫–æ–≤: {e}")
            await message.reply(f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö —É—Ä–æ–∫–æ–≤: {e}")


    else:
        await message.reply("–°–Ω–∞—á–∞–ª–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è. /start")


@dp.message(F.text == 'üë§ –ü—Ä–æ—Ñ–∏–ª—å')
async def profile(message: Message):
    user: User = User.get_or_none(id=message.from_user.id)
    if user:
        profile_info = (
            f"üë§ *–í–∞—à –ø—Ä–æ—Ñ–∏–ª—å:*\n\n"
            f"*–§–ò–û:* {markdown_protect(user.FIO)}\n"
            f"*–õ–æ–≥–∏–Ω:* {markdown_protect(user.login)}\n"
            f"*ID —Å—Ç—É–¥–µ–Ω—Ç–∞:* {user.student_id}\n"
            f"*–°—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è —Ç–æ–∫–µ–Ω–∞:* {datetime.fromtimestamp(user.token_expired).strftime('%Y-%m-%d %H:%M:%S') if user.token_expired else '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'}\n"
        )

        markup = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="‚úñÔ∏è –í—ã–π—Ç–∏ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞", callback_data="logout")]
        ])

        topin = await message.reply(profile_info, parse_mode="Markdown", reply_markup=markup)
        logging.success(f'{message.from_user.id} | {user.FIO} | –í—ã–≤–æ–¥ –ø—Ä–æ—Ñ–∏–ª—è')

    else:
        await message.reply("–°–Ω–∞—á–∞–ª–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è. /start")


@dp.callback_query(F.data == 'logout')
async def logout(callback_query: CallbackQuery):
    user: User = User.get_or_none(id=callback_query.from_user.id)
    if user:
        user.delete_instance()

        await callback_query.message.answer("–í—ã —É—Å–ø–µ—à–Ω–æ –≤—ã—à–ª–∏ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞. /start", reply_markup=ReplyKeyboardRemove())
        await callback_query.answer()
        logging.info(f'{callback_query.from_user.id} | –í—ã—Ö–æ–¥ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞')
    else:
        await callback_query.answer("–í—ã –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã.")


async def send_tomorrow_homework(user: User, session, callback_query: CallbackQuery = None):
    message_id = callback_query.message.message_id if callback_query else None

    tomorrow = (datetime.today() + timedelta(days=1)).strftime("%Y-%m-%d")

    try:
        diary = await user._fetch_data("http://api-mobile.nz.ua/v1/schedule/diary", [tomorrow], session)

        if diary and diary.get('dates'):
            date_data = diary['dates'][0]
            calls = date_data['calls']

            homework_message = f"üìÖ <b>–î–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ –Ω–∞ {tomorrow}:</b>\n\n"

            for call in calls:
                for subject in call['subjects']:
                    if subject['hometask']:
                        homework_message += f"<b>{call['call_number']}. {html.escape(subject['subject_name'])}:</b>\n"
                        for task in subject['hometask']:
                            homework_message += f"‚Ä¢ {html.escape(task)}\n"

            markup = InlineKeyboardMarkup(inline_keyboard=[
                [InlineKeyboardButton(text="üîÑ –û–±–Ω–æ–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ", callback_data=f"refresh_homework:{tomorrow}")]
            ])

            try:
                if message_id:
                    await bot.edit_message_text(
                        homework_message, chat_id=user.id, message_id=message_id,
                        parse_mode="HTML", reply_markup=markup
                    )
                    logging.info(f'{user.id} | {user.FIO} | –î–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ –Ω–∞ –∑–∞–≤—Ç—Ä–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–æ')

                else:
                    await bot.send_message(
                        user.id, homework_message, parse_mode="HTML", reply_markup=markup, disable_web_page_preview=True
                    )
                    logging.info(f'{user.id} | {user.FIO} | –î–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ –Ω–∞ –∑–∞–≤—Ç—Ä–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ')

            except Exception as e:
                if "message is not modified" in str(e):
                    if callback_query: 
                       await bot.answer_callback_query(callback_query.id, "–î–∞–Ω–Ω—ã–µ –∞–∫—Ç—É–∞–ª—å–Ω—ã")
                    logging.info(f'{user.id} | {user.FIO} | –î–∞–Ω–Ω—ã–µ –ø–æ –¥–æ–º–∞—à–Ω–µ–º—É –∑–∞–¥–∞–Ω–∏—é –∞–∫—Ç—É–∞–ª—å–Ω—ã')
                else:
                    raise e

        else:
            not_found_message = f"–ù–∞ –∑–∞–≤—Ç—Ä–∞ ({tomorrow}) –¥–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ."
            if message_id:
                await bot.edit_message_text(not_found_message, chat_id=user.id, message_id=message_id)
            else:
                await bot.send_message(user.id, not_found_message)

    except Exception as e:
        logging.exception(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –¥–æ–º–∞—à–Ω–µ–≥–æ –∑–∞–¥–∞–Ω–∏—è: {e}")
        await bot.send_message(user.id, "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–æ–º–∞—à–Ω–µ–≥–æ –∑–∞–¥–∞–Ω–∏—è.")



async def scheduled_homework_task():
    for user in User.select().where(User.token_expired != None):
        async with aiohttp.ClientSession() as session:
            await send_tomorrow_homework(user, session)




@dp.callback_query(F.data.startswith('refresh_homework:'))
async def refresh_homework(callback_query: CallbackQuery):
    user_id = callback_query.from_user.id
    user = User.get_or_none(id=user_id)
    if user:
        await send_tomorrow_homework(user, callback_query=callback_query)
    else:
        await bot.send_message(user_id, "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è —Å–Ω–æ–≤–∞. /start")
async def main():
    asyncio.create_task(background_task())
    

    scheduler.add_job(scheduled_homework_task, 'cron', hour=11, minute=0)
    scheduler.start()
    await dp.start_polling(bot)

    
if __name__ == '__main__':
    asyncio.run(main())